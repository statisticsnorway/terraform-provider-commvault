
/*
 * Commvault REST API
 *
 * Commvault APIs
 *
 * API version: LATEST
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package apiexplorer

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type AgentApiService service
/*
AgentApiService delete an agent from a server
Used to delete an agent from a server It is expected that the agent has been deconfigured before performing delete operation. But internally if the agent is not deconfigured, then we force deconfigure it to proceed with delete operation Examples of supported agentIds are: 33-File System, 106-Virtual Server
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serverId Id of the server to modify
 * @param agentId Id of the agent to be modified
@return GenericResp
*/
func (a *AgentApiService) DeleteAgent(ctx context.Context, serverId int32, agentId int32) (GenericResp, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GenericResp
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/V4/Server/{serverId}/Agent/{agentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", fmt.Sprintf("%v", serverId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"agentId"+"}", fmt.Sprintf("%v", agentId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authtoken"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GenericResp
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
AgentApiService Disable Backup Property for an Agent
Used to disable backup property for an agent. Types of available agentIds are: 41-Active Directory, 21-AIX File System, 64-Big Data Apps, 134-Cloud Apps, 37-DB2, 103-DB2 MultiNode, 62-DB2 on Unix, 128-Documentum, 90-Domino Mailbox Archiver, 91-DPM, 67-Exchange Compliance Archiver, 53-Exchange Database, 45-Exchange Mailbox, 54-Exchange Mailbox (Classic), 56-Exchange Mailbox Archiver, 82-Exchange PF Archiver, 35-Exchange Public Folder, 73-File Share Archiver, 33-File System, 74-FreeBSD, 71-GroupWise DB, 17-HP-UX Files System, 65-Image Level, 75-Image Level On Unix, 76-Image Level ProxyHost, 87-Image Level ProxyHost on Unix, 3-Informix Database, 29-Linux File System, 89-MS SharePoint Archiver, 104-MySQL, 13-NAS, 83-Netware File Archiver, 12-Netware File System, 10-Novell Directory Services, 124-Object Link, 131-Object Store, 86-OES File System on Linux, 22-Oracle, 80-Oracle RAC, 130-Other External Agent, 125-PostgreSQL, 38-Proxy Client File System, 87-ProxyHost on Unix, 61-SAP for Oracle, 135-SAP HANA, 78-SharePoint Server, 20-Solaris 64bit File System, 19-Solaris File System, 81-SQL Server, 5-Sybase Database, 66-Unix File Archiver, 36-Unix Tru64 64-bit File System, 106-Virtual Server, 58- Windows File Archiver
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serverId Id of the server to modify
 * @param agentId Id of the agent to be modified
 * @param optional nil or *AgentApiDisableBackupAgentOpts - Optional Parameters:
     * @param "EnableAfterADelay" (optional.Int32) -  Provide UTC time in unix format.
@return GenericResp
*/

type AgentApiDisableBackupAgentOpts struct {
    EnableAfterADelay optional.Int32
}

func (a *AgentApiService) DisableBackupAgent(ctx context.Context, serverId int32, agentId int32, localVarOptionals *AgentApiDisableBackupAgentOpts) (GenericResp, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GenericResp
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/V4/Server/{serverId}/Agent/{agentId}/Backup/Action/Disable"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", fmt.Sprintf("%v", serverId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"agentId"+"}", fmt.Sprintf("%v", agentId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.EnableAfterADelay.IsSet() {
		localVarQueryParams.Add("enableAfterADelay", parameterToString(localVarOptionals.EnableAfterADelay.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authtoken"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GenericResp
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
AgentApiService Disable restore property for an agent
Used to disable restore property for an agent Types of available agentIds are: 41-Active Directory, 21-AIX File System, 64-Big Data Apps, 134-Cloud Apps, 37-DB2, 103-DB2 MultiNode, 62-DB2 on Unix, 128-Documentum, 90-Domino Mailbox Archiver, 91-DPM, 67-Exchange Compliance Archiver, 53-Exchange Database, 45-Exchange Mailbox, 54-Exchange Mailbox (Classic), 56-Exchange Mailbox Archiver, 82-Exchange PF Archiver, 35-Exchange Public Folder, 73-File Share Archiver, 33-File System, 74-FreeBSD, 71-GroupWise DB, 17-HP-UX Files System, 65-Image Level, 75-Image Level On Unix, 76-Image Level ProxyHost, 87-Image Level ProxyHost on Unix, 3-Informix Database, 29-Linux File System, 89-MS SharePoint Archiver, 104-MySQL, 13-NAS, 83-Netware File Archiver, 12-Netware File System, 10-Novell Directory Services, 124-Object Link, 131-Object Store, 86-OES File System on Linux, 22-Oracle, 80-Oracle RAC, 130-Other External Agent, 125-PostgreSQL, 38-Proxy Client File System, 87-ProxyHost on Unix, 61-SAP for Oracle, 135-SAP HANA, 78-SharePoint Server, 20-Solaris 64bit File System, 19-Solaris File System, 81-SQL Server, 5-Sybase Database, 66-Unix File Archiver, 36-Unix Tru64 64-bit File System, 106-Virtual Server, 58- Windows File Archiver
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serverId Id of the server to modify
 * @param agentId Id of the agent to be modified
 * @param optional nil or *AgentApiDisableRestoreAgentOpts - Optional Parameters:
     * @param "EnableAfterADelay" (optional.Int32) -  Provide UTC time in unix format.
@return GenericResp
*/

type AgentApiDisableRestoreAgentOpts struct {
    EnableAfterADelay optional.Int32
}

func (a *AgentApiService) DisableRestoreAgent(ctx context.Context, serverId int32, agentId int32, localVarOptionals *AgentApiDisableRestoreAgentOpts) (GenericResp, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GenericResp
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/V4/Server/{serverId}/Agent/{agentId}/Restore/Action/Disable"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", fmt.Sprintf("%v", serverId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"agentId"+"}", fmt.Sprintf("%v", agentId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.EnableAfterADelay.IsSet() {
		localVarQueryParams.Add("enableAfterADelay", parameterToString(localVarOptionals.EnableAfterADelay.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authtoken"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GenericResp
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
AgentApiService Enable Backup Property for an Agent
Used to enable backup property for an agent Types of available agentIds are: 41-Active Directory, 21-AIX File System, 64-Big Data Apps, 134-Cloud Apps, 37-DB2, 103-DB2 MultiNode, 62-DB2 on Unix, 128-Documentum, 90-Domino Mailbox Archiver, 91-DPM, 67-Exchange Compliance Archiver, 53-Exchange Database, 45-Exchange Mailbox, 54-Exchange Mailbox (Classic), 56-Exchange Mailbox Archiver, 82-Exchange PF Archiver, 35-Exchange Public Folder, 73-File Share Archiver, 33-File System, 74-FreeBSD, 71-GroupWise DB, 17-HP-UX Files System, 65-Image Level, 75-Image Level On Unix, 76-Image Level ProxyHost, 87-Image Level ProxyHost on Unix, 3-Informix Database, 29-Linux File System, 89-MS SharePoint Archiver, 104-MySQL, 13-NAS, 83-Netware File Archiver, 12-Netware File System, 10-Novell Directory Services, 124-Object Link, 131-Object Store, 86-OES File System on Linux, 22-Oracle, 80-Oracle RAC, 130-Other External Agent, 125-PostgreSQL, 38-Proxy Client File System, 87-ProxyHost on Unix, 61-SAP for Oracle, 135-SAP HANA, 78-SharePoint Server, 20-Solaris 64bit File System, 19-Solaris File System, 81-SQL Server, 5-Sybase Database, 66-Unix File Archiver, 36-Unix Tru64 64-bit File System, 106-Virtual Server, 58- Windows File Archiver
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serverId Id of the server to modify
 * @param agentId Id of the agent to be modified
@return GenericResp
*/
func (a *AgentApiService) EnableBackupAgent(ctx context.Context, serverId int32, agentId int32) (GenericResp, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GenericResp
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/V4/Server/{serverId}/Agent/{agentId}/Backup/Action/Enable"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", fmt.Sprintf("%v", serverId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"agentId"+"}", fmt.Sprintf("%v", agentId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authtoken"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GenericResp
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
AgentApiService Enable restore property for an agent
Used to enable restore property for an agent Types of available agentIds are: 41-Active Directory, 21-AIX File System, 64-Big Data Apps, 134-Cloud Apps, 37-DB2, 103-DB2 MultiNode, 62-DB2 on Unix, 128-Documentum, 90-Domino Mailbox Archiver, 91-DPM, 67-Exchange Compliance Archiver, 53-Exchange Database, 45-Exchange Mailbox, 54-Exchange Mailbox (Classic), 56-Exchange Mailbox Archiver, 82-Exchange PF Archiver, 35-Exchange Public Folder, 73-File Share Archiver, 33-File System, 74-FreeBSD, 71-GroupWise DB, 17-HP-UX Files System, 65-Image Level, 75-Image Level On Unix, 76-Image Level ProxyHost, 87-Image Level ProxyHost on Unix, 3-Informix Database, 29-Linux File System, 89-MS SharePoint Archiver, 104-MySQL, 13-NAS, 83-Netware File Archiver, 12-Netware File System, 10-Novell Directory Services, 124-Object Link, 131-Object Store, 86-OES File System on Linux, 22-Oracle, 80-Oracle RAC, 130-Other External Agent, 125-PostgreSQL, 38-Proxy Client File System, 87-ProxyHost on Unix, 61-SAP for Oracle, 135-SAP HANA, 78-SharePoint Server, 20-Solaris 64bit File System, 19-Solaris File System, 81-SQL Server, 5-Sybase Database, 66-Unix File Archiver, 36-Unix Tru64 64-bit File System, 106-Virtual Server, 58- Windows File Archiver
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serverId Id of the server to modify
 * @param agentId Id of the agent to be modified
@return GenericResp
*/
func (a *AgentApiService) EnableRestoreAgent(ctx context.Context, serverId int32, agentId int32) (GenericResp, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GenericResp
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/V4/Server/{serverId}/Agent/{agentId}/Restore/Action/Enable"
	localVarPath = strings.Replace(localVarPath, "{"+"serverId"+"}", fmt.Sprintf("%v", serverId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"agentId"+"}", fmt.Sprintf("%v", agentId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authtoken"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GenericResp
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
AgentApiService Gets a list of all the agents configured for a user
To get a list of all the agents configured for a user
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return GetAllApplicableAgentResp
*/
func (a *AgentApiService) GetConfiguredAgents(ctx context.Context) (GetAllApplicableAgentResp, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GetAllApplicableAgentResp
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/V4/CommCell/Agents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authtoken"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GetAllApplicableAgentResp
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
